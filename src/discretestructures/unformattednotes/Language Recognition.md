#  Language Recognition

## Regular Sets and Expressions:

**Regular Sets**: 

Sets that can be built up from concatenation, union, and Kleene closure in arbitrary order with the empty set, empty string, and singleton sets that can also be recognized by a finite-state automaton are called regular sets.

A set is regular if and only if it is recognized by a finite-state automaton.

**Regular Expressions:** 

The regular expressions over a set I are defined recursively by:

* the symbol ∅ is a regular expression; ∅ = set with no strings
* the symbol λ is a regular expression; {λ} = set containing the empty string
* the symbol x is a regular expression whenever x ∈ I; {x} = set containing the string with one symbol x
* the symbols (AB), (A ∪ B) and A^*^ are regular expressions whenever A and B are regular expressions
  * (AB) represents the concatenation of the sets represented by A and by B
  * (A ∪ B) represents the union of the sets represented by A and by B
  * A^∗^ represents the Kleene closure of the set represented by A

**Regular Grammar:**

* A set is generated by a regular grammar if and only if it is a regular set.

### Determining if a string belongs to a regular set

**ex.** Determine whether 0101 belongs to each of these regular sets.

1. 01^*^0^*^

   No

   Possible other sets produced: 010, 01100, 00

2. 0(11)^*^(01)^*^

   No

   Possible other sets produced: 0, 01101, 011110101

3. 0(10)^*^1^*^

   Yes

   Possible other sets produced: 010101, 01011

4.  0^*^10(0∪1)

   Yes

   Possible other sets produced: 100, 101, 0100, 0101

5.  (10)^*^(11)^*^

   No

   Possible other sets produced: 1011, 101011, 101011

### Expressing sets using a regular expression

**ex.** Express each of these sets using a regular expression.

1. **the set consisting of the strings 0, 11, and 010**

   Possible strings : 0, 11, 010

   0  ∪ 11 ∪ 010

2. **the set of strings of three 0s followed by two or more 0s** 

   Possible strings : 00000, 000000, 0000000

   00000^*^

3. **the set of strings of odd length**

   Possible strings : 000, 111, 101, 10101

   (0 ∪ 1)(00 ∪ 01 ∪ 10 ∪ 11)^*^

4. **the set of strings that contain exactly one 1**

   Possible strings : 10, 01, 010

   0^*^10^*^

5. **the set of strings ending in 1 and not containing 000**

   Possible strings : 1, 01, 001, 00001, 101, 1001, 100001

   (1 ∪ 01 ∪ 001)^*^

6.  **the set of strings of one or more 0s followed by a 1**

   Possible strings : 01, 001, 0001

   00^*^1

7.  **the set of strings of two or more symbols followed by three or more 0s**

   Possible strings : 01000, 1110000, 0000000

   (0 ∪ 1)(0 ∪ 1)(0∪1)^*^0000^*^

8.  **the set of strings with either no 1 preceding a 0 OR no 0 preceding a 1**

   Possible strings: 1, 0, 11, 00

   (0^*^1^*^) ∪ (1^*^0^*^)

### Constructing regular grammar given finite-state machine

**ex.** Construct a regular grammar G = (V,T,S,P) that generates the language recognized by the given finite-state machine.

![image-20201221202620525](C:\Users\akshi\Documents\Computer Science\Java Practice\src\discretestructures\Note Images\Regular Grammar from finite state machine ex.png)

s~0~ = S, s~1~ = A, s~2~ = C, s~3~ = B

V = {0, 1, S, A, B, C}; Start Node plus other nodes

T = {0, 1}

P =  S → 0C, S → 1A, A → 0C, C  → 1B, S  → 1, A  →  1, B  → 0, B  → 1, C  → 1

* For productions need to factor that the input doesn't terminate as soon as accepting value is provided. ex. S → 1A vs S  → 1